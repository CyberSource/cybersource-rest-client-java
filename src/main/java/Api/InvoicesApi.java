/*
 * CyberSource Merged Spec
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package Api;

import Invokers.ApiCallback;
import Invokers.ApiClient;
import Invokers.ApiException;
import Invokers.ApiResponse;
import Invokers.Configuration;
import Invokers.Pair;
import Invokers.ProgressRequestBody;
import Invokers.ProgressResponseBody;

import com.cybersource.authsdk.core.ConfigException;
import com.google.gson.reflect.TypeToken;

import java.io.IOException;
import java.io.InputStream;


import Model.CreateInvoiceRequest;
import Model.InvoicingV2InvoicesAllGet200Response;
import Model.InvoicingV2InvoicesAllGet400Response;
import Model.InvoicingV2InvoicesAllGet404Response;
import Model.InvoicingV2InvoicesAllGet502Response;
import Model.InvoicingV2InvoicesCancel200Response;
import Model.InvoicingV2InvoicesGet200Response;
import Model.InvoicingV2InvoicesPost201Response;
import Model.InvoicingV2InvoicesPost202Response;
import Model.InvoicingV2InvoicesPublish200Response;
import Model.InvoicingV2InvoicesPut200Response;
import Model.InvoicingV2InvoicesSend200Response;
import Model.UpdateInvoiceRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import utilities.tracking.SdkTracker;
import com.cybersource.authsdk.util.mle.MLEUtility;
import com.cybersource.authsdk.util.mle.MLEException;

public class InvoicesApi {
    private static Logger logger = LogManager.getLogger(InvoicesApi.class);
    
    private ApiClient apiClient;

    public InvoicesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public InvoicesApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createInvoice
     * @param createInvoiceRequest  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call createInvoiceCall(CreateInvoiceRequest createInvoiceRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        SdkTracker sdkTracker = new SdkTracker();
        Object localVarPostBody = sdkTracker.insertDeveloperIdTracker(createInvoiceRequest, CreateInvoiceRequest.class.getSimpleName(), apiClient.merchantConfig.getRunEnvironment(), apiClient.merchantConfig.getDefaultDeveloperId());
        
        String inboundMLEStatus = "false";

        if (MLEUtility.checkIsMLEForAPI(apiClient.merchantConfig, inboundMLEStatus, "createInvoice,createInvoiceAsync,createInvoiceWithHttpInfo,createInvoiceCall")) {
            try {
                localVarPostBody = MLEUtility.encryptRequestPayload(apiClient.merchantConfig, localVarPostBody);
            } catch (MLEException e) {
                logger.error("Failed to encrypt request body {}", e.getMessage(), e);
                throw new ApiException("Failed to encrypt request body : " + e.getMessage());
            }
        }

        boolean isResponseMLEForApi = MLEUtility.checkIsResponseMLEForAPI(apiClient.merchantConfig, "createInvoice,createInvoiceAsync,createInvoiceWithHttpInfo,createInvoiceCall");
        
        // create path and map variables
        String localVarPath = "/invoicing/v2/invoices";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json;charset=utf-8"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener, isResponseMLEForApi);
    }
    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call createInvoiceValidateBeforeCall(CreateInvoiceRequest createInvoiceRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        
        // verify the required parameter 'createInvoiceRequest' is set
        if (createInvoiceRequest == null) {
            logger.error("Missing the required parameter 'createInvoiceRequest' when calling createInvoice(Async)");
            throw new ApiException("Missing the required parameter 'createInvoiceRequest' when calling createInvoice(Async)");
        }
        
        
        okhttp3.Call call = createInvoiceCall(createInvoiceRequest, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Create a New Invoice
     * The invoicing product enables you to bill any customer with an email address and accept digital payments securely from any connected device. You can either use the system generated email or use the invoice payment link in your own communication. You can add discounts and taxes for the entire invoice or for each line item. To customize the invoice to match your brand see [Invoice Settings](https://developer.cybersource.com/api-reference-assets/index.html#invoicing_invoice-settings_update-invoice-settings). The invoice payment page uses Unified Checkout to process the payments. The availability of API features for a merchant can depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts.
     * @param createInvoiceRequest  (required)
     * @return InvoicingV2InvoicesPost201Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public InvoicingV2InvoicesPost201Response createInvoice(CreateInvoiceRequest createInvoiceRequest) throws ApiException, ConfigException {
        logger.info("CALL TO METHOD 'createInvoice' STARTED");
        ApiResponse<InvoicingV2InvoicesPost201Response> resp = createInvoiceWithHttpInfo(createInvoiceRequest);
        logger.info("CALL TO METHOD 'createInvoice' ENDED");
        return resp.getData();
    }

    /**
     * Create a New Invoice
     * The invoicing product enables you to bill any customer with an email address and accept digital payments securely from any connected device. You can either use the system generated email or use the invoice payment link in your own communication. You can add discounts and taxes for the entire invoice or for each line item. To customize the invoice to match your brand see [Invoice Settings](https://developer.cybersource.com/api-reference-assets/index.html#invoicing_invoice-settings_update-invoice-settings). The invoice payment page uses Unified Checkout to process the payments. The availability of API features for a merchant can depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts.
     * @param createInvoiceRequest  (required)
     * @return ApiResponse&lt;InvoicingV2InvoicesPost201Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public ApiResponse<InvoicingV2InvoicesPost201Response> createInvoiceWithHttpInfo(CreateInvoiceRequest createInvoiceRequest) throws ApiException, ConfigException {
        this.apiClient.setComputationStartTime(System.nanoTime());
        okhttp3.Call call = createInvoiceValidateBeforeCall(createInvoiceRequest, null, null);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesPost201Response>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create a New Invoice (asynchronously)
     * The invoicing product enables you to bill any customer with an email address and accept digital payments securely from any connected device. You can either use the system generated email or use the invoice payment link in your own communication. You can add discounts and taxes for the entire invoice or for each line item. To customize the invoice to match your brand see [Invoice Settings](https://developer.cybersource.com/api-reference-assets/index.html#invoicing_invoice-settings_update-invoice-settings). The invoice payment page uses Unified Checkout to process the payments. The availability of API features for a merchant can depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts.
     * @param createInvoiceRequest  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call createInvoiceAsync(CreateInvoiceRequest createInvoiceRequest, final ApiCallback<InvoicingV2InvoicesPost201Response> callback) throws ApiException, ConfigException {

        this.apiClient.setComputationStartTime(System.nanoTime());
        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = createInvoiceValidateBeforeCall(createInvoiceRequest, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesPost201Response>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getAllInvoices
     * @param offset Page offset number. (required)
     * @param limit Maximum number of items you would like returned. (required)
     * @param status The status of the invoice.  Possible values:   - DRAFT   - CREATED   - SENT   - PARTIAL   - PAID   - CANCELED  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call getAllInvoicesCall(Integer offset, Integer limit, String status, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        SdkTracker sdkTracker = new SdkTracker();
        Object localVarPostBody = null;
        if ("GET".equalsIgnoreCase("POST")) {
            localVarPostBody = "{}";
        }
        
        String inboundMLEStatus = "false";

        if (MLEUtility.checkIsMLEForAPI(apiClient.merchantConfig, inboundMLEStatus, "getAllInvoices,getAllInvoicesAsync,getAllInvoicesWithHttpInfo,getAllInvoicesCall")) {
            try {
                localVarPostBody = MLEUtility.encryptRequestPayload(apiClient.merchantConfig, localVarPostBody);
            } catch (MLEException e) {
                logger.error("Failed to encrypt request body {}", e.getMessage(), e);
                throw new ApiException("Failed to encrypt request body : " + e.getMessage());
            }
        }

        boolean isResponseMLEForApi = MLEUtility.checkIsResponseMLEForAPI(apiClient.merchantConfig, "getAllInvoices,getAllInvoicesAsync,getAllInvoicesWithHttpInfo,getAllInvoicesCall");
        
        // create path and map variables
        String localVarPath = "/invoicing/v2/invoices";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (offset != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));
        if (status != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "status", status));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json;charset=utf-8"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener, isResponseMLEForApi);
    }
    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllInvoicesValidateBeforeCall(Integer offset, Integer limit, String status, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        
        // verify the required parameter 'offset' is set
        if (offset == null) {
            logger.error("Missing the required parameter 'offset' when calling getAllInvoices(Async)");
            throw new ApiException("Missing the required parameter 'offset' when calling getAllInvoices(Async)");
        }
        
        // verify the required parameter 'limit' is set
        if (limit == null) {
            logger.error("Missing the required parameter 'limit' when calling getAllInvoices(Async)");
            throw new ApiException("Missing the required parameter 'limit' when calling getAllInvoices(Async)");
        }
        
        
        okhttp3.Call call = getAllInvoicesCall(offset, limit, status, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get a List of Invoices
     * Provides a (filtered) list of invoices that have been created in your account. You can filter the list based on Invoice Status by setting the status query parameter to one of DRAFT, CREATED, SENT, PARTIAL, PAID or CANCELED.
     * @param offset Page offset number. (required)
     * @param limit Maximum number of items you would like returned. (required)
     * @param status The status of the invoice.  Possible values:   - DRAFT   - CREATED   - SENT   - PARTIAL   - PAID   - CANCELED  (optional)
     * @return InvoicingV2InvoicesAllGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public InvoicingV2InvoicesAllGet200Response getAllInvoices(Integer offset, Integer limit, String status) throws ApiException, ConfigException {
        logger.info("CALL TO METHOD 'getAllInvoices' STARTED");
        ApiResponse<InvoicingV2InvoicesAllGet200Response> resp = getAllInvoicesWithHttpInfo(offset, limit, status);
        logger.info("CALL TO METHOD 'getAllInvoices' ENDED");
        return resp.getData();
    }

    /**
     * Get a List of Invoices
     * Provides a (filtered) list of invoices that have been created in your account. You can filter the list based on Invoice Status by setting the status query parameter to one of DRAFT, CREATED, SENT, PARTIAL, PAID or CANCELED.
     * @param offset Page offset number. (required)
     * @param limit Maximum number of items you would like returned. (required)
     * @param status The status of the invoice.  Possible values:   - DRAFT   - CREATED   - SENT   - PARTIAL   - PAID   - CANCELED  (optional)
     * @return ApiResponse&lt;InvoicingV2InvoicesAllGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public ApiResponse<InvoicingV2InvoicesAllGet200Response> getAllInvoicesWithHttpInfo(Integer offset, Integer limit, String status) throws ApiException, ConfigException {
        this.apiClient.setComputationStartTime(System.nanoTime());
        okhttp3.Call call = getAllInvoicesValidateBeforeCall(offset, limit, status, null, null);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesAllGet200Response>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get a List of Invoices (asynchronously)
     * Provides a (filtered) list of invoices that have been created in your account. You can filter the list based on Invoice Status by setting the status query parameter to one of DRAFT, CREATED, SENT, PARTIAL, PAID or CANCELED.
     * @param offset Page offset number. (required)
     * @param limit Maximum number of items you would like returned. (required)
     * @param status The status of the invoice.  Possible values:   - DRAFT   - CREATED   - SENT   - PARTIAL   - PAID   - CANCELED  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call getAllInvoicesAsync(Integer offset, Integer limit, String status, final ApiCallback<InvoicingV2InvoicesAllGet200Response> callback) throws ApiException, ConfigException {

        this.apiClient.setComputationStartTime(System.nanoTime());
        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getAllInvoicesValidateBeforeCall(offset, limit, status, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesAllGet200Response>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getInvoice
     * @param id The invoice number. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call getInvoiceCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        SdkTracker sdkTracker = new SdkTracker();
        Object localVarPostBody = null;
        if ("GET".equalsIgnoreCase("POST")) {
            localVarPostBody = "{}";
        }
        
        String inboundMLEStatus = "false";

        if (MLEUtility.checkIsMLEForAPI(apiClient.merchantConfig, inboundMLEStatus, "getInvoice,getInvoiceAsync,getInvoiceWithHttpInfo,getInvoiceCall")) {
            try {
                localVarPostBody = MLEUtility.encryptRequestPayload(apiClient.merchantConfig, localVarPostBody);
            } catch (MLEException e) {
                logger.error("Failed to encrypt request body {}", e.getMessage(), e);
                throw new ApiException("Failed to encrypt request body : " + e.getMessage());
            }
        }

        boolean isResponseMLEForApi = MLEUtility.checkIsResponseMLEForAPI(apiClient.merchantConfig, "getInvoice,getInvoiceAsync,getInvoiceWithHttpInfo,getInvoiceCall");
        
        // create path and map variables
        String localVarPath = "/invoicing/v2/invoices/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json;charset=utf-8"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener, isResponseMLEForApi);
    }
    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getInvoiceValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            logger.error("Missing the required parameter 'id' when calling getInvoice(Async)");
            throw new ApiException("Missing the required parameter 'id' when calling getInvoice(Async)");
        }
        
        
        okhttp3.Call call = getInvoiceCall(id, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Invoice Details
     * You can retrieve details of a specific invoice. This can be used to check the Invoice status and get a list of invoice payments in the invoice history section of the response. For each payment transaction you can use the Transaction Details API to get more details on the payment transaction.
     * @param id The invoice number. (required)
     * @return InvoicingV2InvoicesGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public InvoicingV2InvoicesGet200Response getInvoice(String id) throws ApiException, ConfigException {
        logger.info("CALL TO METHOD 'getInvoice' STARTED");
        ApiResponse<InvoicingV2InvoicesGet200Response> resp = getInvoiceWithHttpInfo(id);
        logger.info("CALL TO METHOD 'getInvoice' ENDED");
        return resp.getData();
    }

    /**
     * Get Invoice Details
     * You can retrieve details of a specific invoice. This can be used to check the Invoice status and get a list of invoice payments in the invoice history section of the response. For each payment transaction you can use the Transaction Details API to get more details on the payment transaction.
     * @param id The invoice number. (required)
     * @return ApiResponse&lt;InvoicingV2InvoicesGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public ApiResponse<InvoicingV2InvoicesGet200Response> getInvoiceWithHttpInfo(String id) throws ApiException, ConfigException {
        this.apiClient.setComputationStartTime(System.nanoTime());
        okhttp3.Call call = getInvoiceValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesGet200Response>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Invoice Details (asynchronously)
     * You can retrieve details of a specific invoice. This can be used to check the Invoice status and get a list of invoice payments in the invoice history section of the response. For each payment transaction you can use the Transaction Details API to get more details on the payment transaction.
     * @param id The invoice number. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call getInvoiceAsync(String id, final ApiCallback<InvoicingV2InvoicesGet200Response> callback) throws ApiException, ConfigException {

        this.apiClient.setComputationStartTime(System.nanoTime());
        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = getInvoiceValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesGet200Response>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for performCancelAction
     * @param id The invoice number. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call performCancelActionCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        SdkTracker sdkTracker = new SdkTracker();
        Object localVarPostBody = null;
        if ("POST".equalsIgnoreCase("POST")) {
            localVarPostBody = "{}";
        }
        
        String inboundMLEStatus = "false";

        if (MLEUtility.checkIsMLEForAPI(apiClient.merchantConfig, inboundMLEStatus, "performCancelAction,performCancelActionAsync,performCancelActionWithHttpInfo,performCancelActionCall")) {
            try {
                localVarPostBody = MLEUtility.encryptRequestPayload(apiClient.merchantConfig, localVarPostBody);
            } catch (MLEException e) {
                logger.error("Failed to encrypt request body {}", e.getMessage(), e);
                throw new ApiException("Failed to encrypt request body : " + e.getMessage());
            }
        }

        boolean isResponseMLEForApi = MLEUtility.checkIsResponseMLEForAPI(apiClient.merchantConfig, "performCancelAction,performCancelActionAsync,performCancelActionWithHttpInfo,performCancelActionCall");
        
        // create path and map variables
        String localVarPath = "/invoicing/v2/invoices/{id}/cancelation"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json;charset=utf-8"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener, isResponseMLEForApi);
    }
    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call performCancelActionValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            logger.error("Missing the required parameter 'id' when calling performCancelAction(Async)");
            throw new ApiException("Missing the required parameter 'id' when calling performCancelAction(Async)");
        }
        
        
        okhttp3.Call call = performCancelActionCall(id, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Cancel an Invoice
     * You can cancel an invoice if no payment is made to it. You cannot cancel partially or fully paid invoices.
     * @param id The invoice number. (required)
     * @return InvoicingV2InvoicesCancel200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public InvoicingV2InvoicesCancel200Response performCancelAction(String id) throws ApiException, ConfigException {
        logger.info("CALL TO METHOD 'performCancelAction' STARTED");
        ApiResponse<InvoicingV2InvoicesCancel200Response> resp = performCancelActionWithHttpInfo(id);
        logger.info("CALL TO METHOD 'performCancelAction' ENDED");
        return resp.getData();
    }

    /**
     * Cancel an Invoice
     * You can cancel an invoice if no payment is made to it. You cannot cancel partially or fully paid invoices.
     * @param id The invoice number. (required)
     * @return ApiResponse&lt;InvoicingV2InvoicesCancel200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public ApiResponse<InvoicingV2InvoicesCancel200Response> performCancelActionWithHttpInfo(String id) throws ApiException, ConfigException {
        this.apiClient.setComputationStartTime(System.nanoTime());
        okhttp3.Call call = performCancelActionValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesCancel200Response>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Cancel an Invoice (asynchronously)
     * You can cancel an invoice if no payment is made to it. You cannot cancel partially or fully paid invoices.
     * @param id The invoice number. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call performCancelActionAsync(String id, final ApiCallback<InvoicingV2InvoicesCancel200Response> callback) throws ApiException, ConfigException {

        this.apiClient.setComputationStartTime(System.nanoTime());
        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = performCancelActionValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesCancel200Response>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for performPublishAction
     * @param id The invoice number. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call performPublishActionCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        SdkTracker sdkTracker = new SdkTracker();
        Object localVarPostBody = null;
        if ("POST".equalsIgnoreCase("POST")) {
            localVarPostBody = "{}";
        }
        
        String inboundMLEStatus = "false";

        if (MLEUtility.checkIsMLEForAPI(apiClient.merchantConfig, inboundMLEStatus, "performPublishAction,performPublishActionAsync,performPublishActionWithHttpInfo,performPublishActionCall")) {
            try {
                localVarPostBody = MLEUtility.encryptRequestPayload(apiClient.merchantConfig, localVarPostBody);
            } catch (MLEException e) {
                logger.error("Failed to encrypt request body {}", e.getMessage(), e);
                throw new ApiException("Failed to encrypt request body : " + e.getMessage());
            }
        }

        boolean isResponseMLEForApi = MLEUtility.checkIsResponseMLEForAPI(apiClient.merchantConfig, "performPublishAction,performPublishActionAsync,performPublishActionWithHttpInfo,performPublishActionCall");
        
        // create path and map variables
        String localVarPath = "/invoicing/v2/invoices/{id}/publication"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json;charset=utf-8"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener, isResponseMLEForApi);
    }
    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call performPublishActionValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            logger.error("Missing the required parameter 'id' when calling performPublishAction(Async)");
            throw new ApiException("Missing the required parameter 'id' when calling performPublishAction(Async)");
        }
        
        
        okhttp3.Call call = performPublishActionCall(id, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Publish an Invoice
     * You can publish an invoice in DRAFT status. After invoking this method, the invoice status is changed to CREATED.
     * @param id The invoice number. (required)
     * @return InvoicingV2InvoicesPublish200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public InvoicingV2InvoicesPublish200Response performPublishAction(String id) throws ApiException, ConfigException {
        logger.info("CALL TO METHOD 'performPublishAction' STARTED");
        ApiResponse<InvoicingV2InvoicesPublish200Response> resp = performPublishActionWithHttpInfo(id);
        logger.info("CALL TO METHOD 'performPublishAction' ENDED");
        return resp.getData();
    }

    /**
     * Publish an Invoice
     * You can publish an invoice in DRAFT status. After invoking this method, the invoice status is changed to CREATED.
     * @param id The invoice number. (required)
     * @return ApiResponse&lt;InvoicingV2InvoicesPublish200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public ApiResponse<InvoicingV2InvoicesPublish200Response> performPublishActionWithHttpInfo(String id) throws ApiException, ConfigException {
        this.apiClient.setComputationStartTime(System.nanoTime());
        okhttp3.Call call = performPublishActionValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesPublish200Response>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Publish an Invoice (asynchronously)
     * You can publish an invoice in DRAFT status. After invoking this method, the invoice status is changed to CREATED.
     * @param id The invoice number. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call performPublishActionAsync(String id, final ApiCallback<InvoicingV2InvoicesPublish200Response> callback) throws ApiException, ConfigException {

        this.apiClient.setComputationStartTime(System.nanoTime());
        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = performPublishActionValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesPublish200Response>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for performSendAction
     * @param id The invoice number. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call performSendActionCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        SdkTracker sdkTracker = new SdkTracker();
        Object localVarPostBody = null;
        if ("POST".equalsIgnoreCase("POST")) {
            localVarPostBody = "{}";
        }
        
        String inboundMLEStatus = "false";

        if (MLEUtility.checkIsMLEForAPI(apiClient.merchantConfig, inboundMLEStatus, "performSendAction,performSendActionAsync,performSendActionWithHttpInfo,performSendActionCall")) {
            try {
                localVarPostBody = MLEUtility.encryptRequestPayload(apiClient.merchantConfig, localVarPostBody);
            } catch (MLEException e) {
                logger.error("Failed to encrypt request body {}", e.getMessage(), e);
                throw new ApiException("Failed to encrypt request body : " + e.getMessage());
            }
        }

        boolean isResponseMLEForApi = MLEUtility.checkIsResponseMLEForAPI(apiClient.merchantConfig, "performSendAction,performSendActionAsync,performSendActionWithHttpInfo,performSendActionCall");
        
        // create path and map variables
        String localVarPath = "/invoicing/v2/invoices/{id}/delivery"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json;charset=utf-8"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener, isResponseMLEForApi);
    }
    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call performSendActionValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            logger.error("Missing the required parameter 'id' when calling performSendAction(Async)");
            throw new ApiException("Missing the required parameter 'id' when calling performSendAction(Async)");
        }
        
        
        okhttp3.Call call = performSendActionCall(id, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Send an Invoice
     * You can send an invoice in draft or created state or resend a sent or partially paid invoice. Fully paid or canceled invoices cannot be resent.
     * @param id The invoice number. (required)
     * @return InvoicingV2InvoicesSend200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public InvoicingV2InvoicesSend200Response performSendAction(String id) throws ApiException, ConfigException {
        logger.info("CALL TO METHOD 'performSendAction' STARTED");
        ApiResponse<InvoicingV2InvoicesSend200Response> resp = performSendActionWithHttpInfo(id);
        logger.info("CALL TO METHOD 'performSendAction' ENDED");
        return resp.getData();
    }

    /**
     * Send an Invoice
     * You can send an invoice in draft or created state or resend a sent or partially paid invoice. Fully paid or canceled invoices cannot be resent.
     * @param id The invoice number. (required)
     * @return ApiResponse&lt;InvoicingV2InvoicesSend200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public ApiResponse<InvoicingV2InvoicesSend200Response> performSendActionWithHttpInfo(String id) throws ApiException, ConfigException {
        this.apiClient.setComputationStartTime(System.nanoTime());
        okhttp3.Call call = performSendActionValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesSend200Response>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Send an Invoice (asynchronously)
     * You can send an invoice in draft or created state or resend a sent or partially paid invoice. Fully paid or canceled invoices cannot be resent.
     * @param id The invoice number. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call performSendActionAsync(String id, final ApiCallback<InvoicingV2InvoicesSend200Response> callback) throws ApiException, ConfigException {

        this.apiClient.setComputationStartTime(System.nanoTime());
        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = performSendActionValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesSend200Response>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateInvoice
     * @param id The invoice number. (required)
     * @param updateInvoiceRequest Updating the invoice does not resend the invoice automatically. You must resend the invoice separately. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call updateInvoiceCall(String id, UpdateInvoiceRequest updateInvoiceRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        SdkTracker sdkTracker = new SdkTracker();
        Object localVarPostBody = sdkTracker.insertDeveloperIdTracker(updateInvoiceRequest, UpdateInvoiceRequest.class.getSimpleName(), apiClient.merchantConfig.getRunEnvironment(), apiClient.merchantConfig.getDefaultDeveloperId());
        
        String inboundMLEStatus = "false";

        if (MLEUtility.checkIsMLEForAPI(apiClient.merchantConfig, inboundMLEStatus, "updateInvoice,updateInvoiceAsync,updateInvoiceWithHttpInfo,updateInvoiceCall")) {
            try {
                localVarPostBody = MLEUtility.encryptRequestPayload(apiClient.merchantConfig, localVarPostBody);
            } catch (MLEException e) {
                logger.error("Failed to encrypt request body {}", e.getMessage(), e);
                throw new ApiException("Failed to encrypt request body : " + e.getMessage());
            }
        }

        boolean isResponseMLEForApi = MLEUtility.checkIsResponseMLEForAPI(apiClient.merchantConfig, "updateInvoice,updateInvoiceAsync,updateInvoiceWithHttpInfo,updateInvoiceCall");
        
        // create path and map variables
        String localVarPath = "/invoicing/v2/invoices/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json;charset=utf-8"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().newBuilder().addNetworkInterceptor(new okhttp3.Interceptor() {
                @Override
                public okhttp3.Response intercept(okhttp3.Interceptor.Chain chain) throws IOException {
                    okhttp3.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener, isResponseMLEForApi);
    }
    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateInvoiceValidateBeforeCall(String id, UpdateInvoiceRequest updateInvoiceRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException, ConfigException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            logger.error("Missing the required parameter 'id' when calling updateInvoice(Async)");
            throw new ApiException("Missing the required parameter 'id' when calling updateInvoice(Async)");
        }
        
        // verify the required parameter 'updateInvoiceRequest' is set
        if (updateInvoiceRequest == null) {
            logger.error("Missing the required parameter 'updateInvoiceRequest' when calling updateInvoice(Async)");
            throw new ApiException("Missing the required parameter 'updateInvoiceRequest' when calling updateInvoice(Async)");
        }
        
        
        okhttp3.Call call = updateInvoiceCall(id, updateInvoiceRequest, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Update an Invoice
     * You can update all information except the invoice number till any payment is received for an invoice. Invoices that are partially or fully paid or cancelled cannot be updated.
     * @param id The invoice number. (required)
     * @param updateInvoiceRequest Updating the invoice does not resend the invoice automatically. You must resend the invoice separately. (required)
     * @return InvoicingV2InvoicesPut200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public InvoicingV2InvoicesPut200Response updateInvoice(String id, UpdateInvoiceRequest updateInvoiceRequest) throws ApiException, ConfigException {
        logger.info("CALL TO METHOD 'updateInvoice' STARTED");
        ApiResponse<InvoicingV2InvoicesPut200Response> resp = updateInvoiceWithHttpInfo(id, updateInvoiceRequest);
        logger.info("CALL TO METHOD 'updateInvoice' ENDED");
        return resp.getData();
    }

    /**
     * Update an Invoice
     * You can update all information except the invoice number till any payment is received for an invoice. Invoices that are partially or fully paid or cancelled cannot be updated.
     * @param id The invoice number. (required)
     * @param updateInvoiceRequest Updating the invoice does not resend the invoice automatically. You must resend the invoice separately. (required)
     * @return ApiResponse&lt;InvoicingV2InvoicesPut200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public ApiResponse<InvoicingV2InvoicesPut200Response> updateInvoiceWithHttpInfo(String id, UpdateInvoiceRequest updateInvoiceRequest) throws ApiException, ConfigException {
        this.apiClient.setComputationStartTime(System.nanoTime());
        okhttp3.Call call = updateInvoiceValidateBeforeCall(id, updateInvoiceRequest, null, null);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesPut200Response>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an Invoice (asynchronously)
     * You can update all information except the invoice number till any payment is received for an invoice. Invoices that are partially or fully paid or cancelled cannot be updated.
     * @param id The invoice number. (required)
     * @param updateInvoiceRequest Updating the invoice does not resend the invoice automatically. You must resend the invoice separately. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @throws ConfigException If creation of merchant configuration fails in ApiClient
     */
    public okhttp3.Call updateInvoiceAsync(String id, UpdateInvoiceRequest updateInvoiceRequest, final ApiCallback<InvoicingV2InvoicesPut200Response> callback) throws ApiException, ConfigException {

        this.apiClient.setComputationStartTime(System.nanoTime());
        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        okhttp3.Call call = updateInvoiceValidateBeforeCall(id, updateInvoiceRequest, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InvoicingV2InvoicesPut200Response>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
