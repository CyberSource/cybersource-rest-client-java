/*
 * CyberSource Merged Spec
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package Model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * GeneratePublicKeyRequest
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2021-04-21T20:24:19.795+05:30")
public class GeneratePublicKeyRequest {
  @SerializedName("encryptionType")
  private String encryptionType = null;

  @SerializedName("targetOrigin")
  private String targetOrigin = null;

  public GeneratePublicKeyRequest encryptionType(String encryptionType) {
    this.encryptionType = encryptionType;
    return this;
  }

   /**
   * How the card number should be encrypted in the subsequent Tokenize Card request. Possible values are RsaOaep256 or None (if using this value the card number must be in plain text when included in the Tokenize Card request). The Tokenize Card request uses a secure connection (TLS 1.2+) regardless of what encryption type is specified.
   * @return encryptionType
  **/
  @ApiModelProperty(required = true, value = "How the card number should be encrypted in the subsequent Tokenize Card request. Possible values are RsaOaep256 or None (if using this value the card number must be in plain text when included in the Tokenize Card request). The Tokenize Card request uses a secure connection (TLS 1.2+) regardless of what encryption type is specified.")
  public String getEncryptionType() {
    return encryptionType;
  }

  public void setEncryptionType(String encryptionType) {
    this.encryptionType = encryptionType;
  }

  public GeneratePublicKeyRequest targetOrigin(String targetOrigin) {
    this.targetOrigin = targetOrigin;
    return this;
  }

   /**
   * The merchant origin (e.g. https://example.com) used to integrate with Flex API. Required to comply with CORS and CSP standards.
   * @return targetOrigin
  **/
  @ApiModelProperty(value = "The merchant origin (e.g. https://example.com) used to integrate with Flex API. Required to comply with CORS and CSP standards.")
  public String getTargetOrigin() {
    return targetOrigin;
  }

  public void setTargetOrigin(String targetOrigin) {
    this.targetOrigin = targetOrigin;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GeneratePublicKeyRequest generatePublicKeyRequest = (GeneratePublicKeyRequest) o;
    return Objects.equals(this.encryptionType, generatePublicKeyRequest.encryptionType) &&
        Objects.equals(this.targetOrigin, generatePublicKeyRequest.targetOrigin);
  }

  @Override
  public int hashCode() {
    return Objects.hash(encryptionType, targetOrigin);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GeneratePublicKeyRequest {\n");
    
    sb.append("    encryptionType: ").append(toIndentedString(encryptionType)).append("\n");
    sb.append("    targetOrigin: ").append(toIndentedString(targetOrigin)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

